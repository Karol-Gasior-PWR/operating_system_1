Problemy ()

TOCTOU(Time of Check to Time of Use)


if (thread_counter.load(std::memory_order_relaxed) < MAX_THREADS) {
    thread_counter.fetch_add(1, std::memory_order_relaxed);
    // tworzymy nowy wątek
}
W takim przypadku, między sprawdzeniem zawartości thread_counter a jej inkrementacją może dojść do jego sprawdzenia w innych wątkach a w efekcie wejście do wnętrz instrukcji if w wielu wątkach. Następnie w każdym z tych wątków następuje inkrementacja thread_counter, co może doprowadzić do sytuacji, żę thread_counter > MAX_THREADS. Czyli ograniczenie liczby watków nie będzie działać prawidłowo.

Rozwiązaniem tego problemu jest użycie <semaphore> (c++20) lub wzorca projektowego CAS-loop (compare and swap)

auto old = thread_counter.load();
while(old < MAX_THREADS)
{
	if (thread_counter.compare_exchange_weak (old, old+1))
		//stworz watek i wyjdz
		
}
instrukcja compare_exchange_weak jest atomowa instukcja CPU nazywana cas, ponieważ jeżeli sprawdzenie niepowiedzie się, zawartość old jest aktualizowana. 

Jeszcze lepszym rozwiazaniem jest uzycie std::semaphore
Odzwierciedleniem powyższego kodu czyli blokujące tworzenie wątku wymaga użycia std::counting_semaphor.acquire(). Instrukcja ta sprawdza czy zawartośc semaphore jest większa od 0, jeśli nie, wątek jest usypiany. Po zakończeniu wykonywania wątku należy uzyć std::counting_semaphor.release() aby zwiększyć wartośc przetezymywana przez semaphore. Acquire i release nie muszą zwiększać i zmniejszać wartości o 1, mogą przyjac większe dodatnie wartości. 

Takie podejście w przypadku rekurencyjnego wywołania kolejnych wątków może spowodować deadlock, mamy n czekających watków, gdzie n to wartość podana do semaphore podczas jego tworzenia. Dlatego w implemntacji współbieżenej algorytmu QuickSort zamiast acquire zastosowano std::counting_semaphor.try_acquire() które zwraca wartość true i oraz zwiększa wartość, jeżeli zawartość większa od 0, oraz false dla 0. W przeciwiństwie do acquire() bierzący wątek nie jest usypiany. 



ulimit -u - instrukcja w linux sprawdzająca maksymalną ilość procesów/wątków którą można utworzyć w systemie, przekroczenie tej liczby rzuci w c++ wyjątek :

ulimit -s -maksymalny rozmiar stack w kB, jest on przydzielany każdemu wątkowi oddzielnie. 



Opis kodu:

quickSort - sekwencyjna wersja algorytmu quickSort


/*!
 * \brief quickSort_depth
 * \param b indeks początku tablicy
 * \param e indeks końca tablicy
 * \param tab adres tablicy
 * \param depth ile poziomów głebiej można zejść wykonując implementację współbieżną, od 0 - przejście na wersję sekwencyjną
 * \param thread_slots  nieblokująca semaphore które służy do zliczania wątków, określa kiedy przejść na wersję sekwencyjną.
 */

void quickSort_depth(unsigned int b, unsigned int e, int tab[], unsigned int depth, std::counting_semaphore<semaphore_max> & thread_slots)
{
    if(! is_tab_valid(b,e,tab))
        return;

    //divide
    int pivIdx = e;    //here pivIdx should be calculated
    pivIdx = partition(b, e, pivIdx, tab);

    if(depth == 0) //osiagnieto max glebokosc, od tego momenty sekwencyjnie
    {
        quickSort(b, pivIdx-1, tab);
        quickSort(pivIdx+1, e, tab);
    }
    else
    {
        if(thread_slots.try_acquire()) //zdobadz slot na watek
        {
            std::thread second{ [b, pivIdx, tab, depth, &thread_slots]()
                {
                    quickSort_depth(b, pivIdx - 1, tab, depth - 1, thread_slots);
                    thread_slots.release(); //zwolnij slot
                }
            };
            quickSort_depth(pivIdx + 1, e, tab, depth - 1, thread_slots);
            second.join();
        }
        else	//jesli brak wolnego slotu, dokończ to wywołanie rekurencji sekwencyjnie. ! kolejne wywołania mogą tworzyć nowe wątki
        {
            quickSort_depth(b, pivIdx - 1, tab, depth - 1, thread_slots);
            quickSort_depth(pivIdx + 1, e, tab, depth - 1, thread_slots);
        }

    }
}

Do uwalniania semaphore nie zastosowano RAII, ponieważ sam algorytm i insttrukcjie w nim zastosowane nie rzucają wyjątków. W przypadku wystąpienia ogólnych wyjątków (np. naruszenie pamięci, przekroczenie rozmiaru stack), cały program ma się zakończyć.

Wersja QuickSort z ograniczeniem rozmiaru podtablicy, od którego algorytm ma zacząc się wykonywać sekwencyjnie jest analogiczny do wersji depth.


Opis podejścia:

Zastosowano podejście w którym narzucono dwa ograniczenia na tworzenie się nowych wątków. Pierwszy to rozmiar problemu drugi to ilość aktywnych wątków wykonywanych w ramach algorytmu QuickSort. 


Wnioski:



Wywoływanie nowych wątków dla zbyt małych problemów, (rozmiary mniejsze niż około 150 elementów, brak ograniczenia liczby wątków) prowadziło do zwiększenia czasu wykonywania algorytmu. Jest to spowodowane narzutem jaki powoduje utworzenie nowego wątku oraz kosztem przełączania kontekstu gdy wątków jest bardzo dużo. W przypadku prostego ograniczenia liczby wątków nie jest to tak dobrze widoczne jak w przypadku implementacji z kolejką zadań, gdzie koszt przełączania konteksu między dużą liczbą watków nie wpływa na czas wykonywania algorytmu. Zauważalny jest wzrost czasu wykonywania algorytmu, gdy maksymalna liczba wątków przekracza liczbę logicznych rdzeni. Widoczny jest również spadek zysku, gdy liczba wątków przekroczy liczbę rdzeni. Zwiększanie liczby wątków nadal skraca czas wykonywania algorytmu, ale w mniejszym stopniu. 

Proste ograniczenie liczby wątków napotyka następujące problemy, które częsciowo łagodzi implementacja z kolejką zadań. Zależnie od rozłożenia elementów w tablicy, podtablica lewa i prawa mogą mieć bardzo rózne rozmiary. Ponieważ w tym wypadku nie ma żadnej kontroli na kolejnością wykonywania się wątków, może dojść do sytuacji, że dla dużych podtablic ze względu na brak dostępnych slotów na nowe wątki poziom gałęzi będzie wykonywać się sekwencyjnie, zaś wątki z małymi podtablicami będą ciągle okupować sloty na wątki. W takim przypadku może dojść do sytuacji, gdzie liczba aktywnych wątków będzie małą. Ponieważ jedna strona gałęźi wywołań rekurencyjnych się zakończy, zaś druga strona z dużymi podtablicami nadal będzie się wykonywać sekwencyjnie i nie "nadąży" z tworzeniem nowych wątków. Również ten problem mocno łagodzi implemntacja z priorytetową kolejką zadań, tutaj opis wstawić od kolejkowicza.

Należy pamiętać, że badania nie były wykonywane na izolowanym CPU, więc wyniki są uśrednioniem z wielu sortowań tej samej tablicy elemntów. System wykonuje również inne zadania w tle i nie zawsze przydziela rdzenie wyłącznie dla wątków powiązanych z opisywanym programem.

Jeśli są wyniki dla simple quick sort, to przez udostępnianego przez niego atomika można zrobić wykres aktiv_thread/max_threads w funkcji czasu.


